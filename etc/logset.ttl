# An ontology for metadata describing log-like information about HPC systems,
# intended to support analysis of faults and failures.
#
# a client should be able to query a graph of logset objects to find, eg
# logfiles and job records etc about a specific job. or affected by a 
# specific component failure

# basic vocabularies used here:
# rdf and rdfs between them define essential types and relationships:
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
# owl adds a more constrained formal description logic for classes:
@prefix owl: <http://www.w3.org/2002/07/owl#> .
# dublin core terms, form base of dcat vocab:
@prefix dct: <http://purl.org/dc/terms/> .
# to compare dateTime types:
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# the dataset definition is derived from the Data Catalog Vocabulary, a single
# dataset is a subtype of dcat:Dataset and can be managed as part of a 
# dcat:Catalog and published/accessed as a dcat:Distribution
# (note that Catalogs can link to other Catalogs, and to rdf descriptions
# of Subjects such as "Cori", "cscratch" and their relationships, via 
# rdfs:seeAlso)
@prefix dcat: <http://www.w3.org/ns/dcat#> .

# each ConcreteLog contains entries about some Entity, and is and instanceOf
# some LogSeries providing some "type" of information ("InfoType", eg "job_records"
# or "log_messages" or "queue_snapshots" or "annotations"). The Entity and 
# InfoType are describes as skos:Concepts:
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .

# valid urls/bases/prefixes include:
#@prefix dict: <https://raw.githubusercontent.com/NERSC/LogSet/master/etc/dict#> .
#@prefix dict: <file:///global/homes/s/sleak/Monitoring/Resilience/LogSet/etc/dict#> .
#@prefix dict: <../etc/dict#> .

# declare myself and set a prefix:
#@base <https://raw.githubusercontent.com/NERSC/LogSet/master/etc> .
@base <http://portal.nersc.gov/project/mpccc/sleak/resilience/datasets/> .
@prefix : <logset#> .
:
    a owl:Ontology ;
    dct:title "the LogSet vocabulary" ;
    rdfs:label "LogSet" ;
    .

# the classes in our vocabulary:
:LogSet
    a owl:Class ;
    rdfs:subClassOf dcat:Dataset ;
    rdfs:comment ''' A LogSet is a dcat:Dataset of related logs (eg, the logs 
                     from a Cray boot session on NERSC Cori - related in system
                     and access and timespan)
                     It is recommended but not enforced that a LogSet instance 
                     should have certain properties describing its provenance:   
                     # dct:title         a rdfs:Literal
                     # dct:description   a rdfs:Literal
                     # dct:publisher     a foaf:Organization
                     # dct:contactPoint  a vcard:Kind
                     (publisher and contactPoint are especially useful when the
                     actual log data is not directly accessible to people or 
                     tools using the metadata, so that having identified that 
                     data exists, they can contact someone to request access).
                     The actual files (or db queries etc) of the logs are 
                     described as a :ConcreteLog, based on dcat:Distribution.
                     A LogSet is epected to be defined in its own index file
                     and included in a dcat:Catalog
                 ''' ;
    .

:LogSeries
    a owl:Class;
    rdfs:comment ''' A "type" of logfile, eg a console or outage log. Might be
                     specific to a type of system, or OS version, but common to
                     systems of that type (eg Cray with CNL6). Can be used by
                     tools to indicate how to handle a log. Must have a property
                     indicating the "canonical" format that tools can assume on.
                     Note: we may need to add an "equivalentTo" property for 
                     LogSeries that can be in multiple places and formats, eg a
                     text log on a server and an index in an ElasticSearch db.
                     A LogSeries is expected to be defined in a data dictionary
                 ''' ;
    rdfs:subClassOf [
        rdf:type owl:Restriction ;
        owl:onProperty :infoType ;  
        # any LogSeries must have *some* type of entries, and some might have 
        # several, eg a slurm_instance has job_records and also node_state
        owl:minCardinality 1 ; 
    ] ;
    rdfs:subClassOf [
        rdf:type owl:Restriction ;
        owl:onProperty :logFormatType ;  # must specify a format
        owl:cardinality 1 ;
    ] ;
    .

:LogFormatType
    a owl:Class ;
    rdfs:comment ''' An entity representing how log data is organized, in order 
                     to help tools decide how to handle a give log.  
                     For example, most logs are timestamped-line-per-entry but
                     some are a timestamped multiline block, others have a file
                     per timestamp and contain a table, others hove no obvious 
                     structure at all. 
                     It is likely valuable for a LogFormatType to include a
                     dcat:mediaType property, eg "text/plain" 
                     A LogFormatType is expected to be defined in a data 
                     dictionary and to correspond to a handler class for logs in
                     that format
                 ''' ;
    rdfs:subClassOf [
        rdf:type owl:Restriction ;
        owl:onProperty dcat:mediaType ;  # may specify a mime type
        owl:maxCardinality 1 ;
    ] ;
    .

:InfoType
    a owl:Class ;
    rdfs:subClassOf skos:Concept ;
    rdfs:comment ''' What the entries in a LogSeries are, eg "log_messages"
                     or "job_records". As an skos:Concept, InfoTypes can be 
                     linked as skos:narrower/broader/related
                 ''' ;
    . 

:Subject
    a owl:Class ;
    #rdfs:subClassOf skos:Concept ;
    rdfs:comment ''' A thing that a ConcreteLog is about, eg a system or 
                     subsystem, or even a specific job 
                 ''' ;
    .

:ConcreteLog
    a owl:Class ;
    rdfs:label "ConcreteLog" ; 
    rdfs:subClassOf dcat:Distribution ;
    # required properties:
    rdfs:subClassOf [
        rdf:type owl:Restriction ;
        owl:onProperty :isInstanceOf ; # eg dict:console_logfile
        owl:cardinality 1 ;
    ] ;
    rdfs:subClassOf [
        rdf:type owl:Restriction ;
        owl:onProperty dct:temporal ; 
        owl:cardinality 1 ;
        # dct:temporal is poorly defined, so following the example of DDI and
        # others, use a blank node like:
        # dct:temporal [ a dct:PeriodOfTime ;
        #   logset:startDate "2017-09-06T15:18:20.827169-07:00"^^xsd:dateTime ;
        #   logset:endDate "2017-09-07T15:22:42.809617-07:00"^^xsd:dateTime ;
        #   ] ;
    ] ;
    rdfs:subClassOf [
        rdf:type owl:Restriction ;
        owl:onProperty :subject ; 
          # eg: <http://portal.nersc.gov/project/m888/resilience/entities/#edison>
        owl:minCardinality 1 ;
    ] ;
    rdfs:comment ''' An actual, specific log, eg a File or database or web 
                     service, with knowledge of how to handle this type of 
                     log in this format. Eg, the actual files in a p0 package
                     are ConcreteLog objects.
                     Should have either a dcat:downloadURL or a dcat:accessURL.
                 ''' ;
    .


# and the properties linking them:

:subject 
    a owl:ObjectProperty ;
    rdfs:comment ''' The entity whose state this LogSet or ConcreteLog describes.
                     (eg a console-log might be for nersc:edison)
                 ''' ;
    rdfs:domain :ConcreteLog ;
    rdfs:range :Subject ;
    .

:specificSubjectPattern
    a owl:DatatypeProperty ;
    rdfs:comment ''' While major system components are represented by a Subject,
                     representing specific smaller components (such as compute nodes
                     or hsn links) is impractical. To indicate that a log (or LogSet)
                     is about eg a specific node, or a subset of links, this literal 
                     label can be added
                 ''' ;
    rdfs:domain :ConcreteLog ;
    rdfs:range rdfs:Literal ;
    .


:affects
    a owl:ObjectProperty ;
    rdfs:comment ''' Components in an HPC center are not a strict hierarchy,
                     eg a filesystem might be shared by multiple systems. 
                     So we connect related systems and subsystems with an 
                     "affects" relationship
                 ''' ;
    rdfs:domain :Subject ;
    rdfs:range :Subject ;
    .

# is this valid? 
:partOf
    a owl:ObjectProperty ;
    rdfs:subClassOf :affects ;
    rdfs:comment ''' isubclass of affects for things that really are part of a strict hierarchy 
                 ''' ;
    rdfs:domain :Subject ;
    rdfs:range :Subject ;
    .

:relevantLogSeries
    a owl:ObjectProperty ;
    rdfs:comment ''' to help in locating/defining subjects for logs, having a list of known 
                     LogSeries that are relevant to a subject might help guide the cataloger
                     to list subjects sensibly
                 ''';
    rdfs:domain :Subject ;
    rdfs:range :LogSeries ;
    .

# make dct:temporal amenable to sparql queries, following the pattern used by
# DDI Alliance and OpenGeoSpatial.org of defining startDate and endDate properties
# for a dct:PeriodOfTime, and in indexes and queries use a nested blank node for
# the dct:PeriodOfTime itself.
# Note that for sparql queries to work, the dates *must* be include a timezone
# and be marked as ^^xsd:dateTime, both in the index and in the query (or they
# get compared as literals). The time part (eg T12:00:00) is optional
:startDate
    a owl:DatatypeProperty ;
    rdfs:domain dct:PeriodOfTime ;
    rdfs:range xsd:dateTime ;
    .

:endDate
    a owl:DatatypeProperty ;
    rdfs:domain dct:PeriodOfTime;
    rdfs:range xsd:dateTime ;
    .

# other useful, optional info about a concretelog:
# dcat:byteSize
:recordCount
    a owl:DatatypeProperty ;
    rdfs:domain :ConcreteLog ;
    rdfs:range xsd:integer ;
    .

:estRecordCount
    a owl:DatatypeProperty ;
    rdfs:domain :ConcreteLog ;
    rdfs:range xsd:integer ;
    rdfs:comment ''' an estimate of the number of records in a ConcreteLog,
                     if that is guessable/appropriate
                 ''' ;
    .


:logFormatType
    a owl:ObjectProperty, owl:FunctionalProperty ;
    rdfs:comment ''' the LogFormatType for this LogSeries
                 ''' ;
    rdfs:domain :LogSeries ;
    rdfs:range :LogFormatType ;
    .

:infoType
    a owl:ObjectProperty, owl:FunctionalProperty ;
    rdfs:comment ''' the InfoType for this LogSeries
                 ''' ;
    rdfs:domain :LogSeries ;
    rdfs:range :InfoType ;
    .

:logFormatInfo
    a owl:DatatypeProperty ;
    rdfs:comment ''' dictionary-like information that a LogFormatType handler 
                     class can use to interpret a specific type of logfile. Each 
                     logFormatInfo property should be a literal like 
                     "key=value". Eg, a console_logfile and message_logfile are
                     both timeStampedLogFile, but in the console log the 
                     timestamp is the first "word" on each line, while in the 
                     message log the timestamp is the second word on each line.
                     So console_logfile can have recordInfoProperty "ts_word=0"
                     (and "part_word=1" for system component) 
                 ''' ;
    rdfs:domain :LogSeries ;
    rdfs:range rdfs:Literal ;
    .

:isInstanceOf
    a owl:ObjectProperty, owl:FunctionalProperty ;
    rdfs:comment "Links a LogSeries to log data (eg a log file)" ;
    rdfs:domain :ConcreteLog ;
    rdfs:range :LogSeries ;
    .

# when indexing a bunch of logs, its helpful to be able to use filename patterns
# to guess the logseries based on the filename (eg messages-20170129 is a messages
# logfile for Jan 29, 2017). In practice this can be implemented by checking 
# filenames against a regex. But getting the regex right for every LogSeries is 
# tedious and unreliable, so we'll set up a kind of database of tags and patterns.
# the actual tags and patterns are in dicts instead of the vocab, because they
# are implementation-specific and will grow over time, but the vocab parts are:
:FilenamePattern a owl:Class .

:tag    
    a owl:DatatypeProperty ;
    rdfs:domain :FilenamePattern ;
    rdfs:range rdfs:Literal ;
    .

:regex
    a owl:DatatypeProperty ;
    rdfs:domain :FilenamePattern ;
    rdfs:range rdfs:Literal ;
    .


